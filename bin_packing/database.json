{"init -3": 
    {"code": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n  def s(bin, item):\n    if bin - item <= 2:\n      return 4\n    elif (bin - item) <= 3:\n      return 3\n    elif (bin - item) <= 5:\n      return 2\n    elif (bin - item) <= 7:\n      return 1\n    elif (bin - item) <= 9:\n      return 0.9\n    elif (bin - item) <= 12:\n      return 0.95\n    elif (bin - item) <= 15:\n      return 0.97\n    elif (bin - item) <= 18:\n      return 0.98\n    elif (bin - item) <= 20:\n      return 0.98\n    elif (bin - item) <= 21:\n      return 0.98\n    else:\n      return 0.99\n\n  return np.array([s(b, item) for b in bins])", 
     "Intuition": "The heuristic assigns varying scores to bins based on the remaining space after adding an item, favoring bins that would be more evenly filled.", 
     "score": 0.07237512742099907, 
     "parents": [0, 0],
     "equivalency": "None"}, 
"init -2": 
     {"code": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    return (bins-item)>=0", 
      "Intuition": "To place each item into the bin that would leave the least amount of empty space after the item is packed. ",
      "score": 0.08358817533129463, 
      "parents": [0, 0],
      "equivalency": "None"},
"init -1": 
    {"code": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    return -(bins-item)", 
     "Intuition": "To place each item into the bin that would leave the least amount of empty space after the item is packed. ",
     "score": 0.07645259938837921, 
     "parents": [0, 0],
     "equivalency": "None"}}
